# SQL ソート ORDER BY
ソートは、データの並べ替えのことです。昇順、降順のことですね。  
めちゃくちゃ大事な事が標準SQL規格99に書いてあります。

ORDER BY で並び替えを明示しない限り、RMDBSの実装に委ねることになるということです。  
特にPostgreSQLは追記型DBのアーキテクチャを採用しているので、ORDER BY でソートを明示しないと  
びっくりするぐらい順序が変わってしまいます。

データベースの管理として追記型DBでは、レコードに更新があった場合に、元々あったレコードを利用するのではなく、  
前のあったレコードとは別に新しいレコードを追加させて、前のレコードのポインタ(位置情報だけを)を消すようなアーキテクチャです。

# ORDER BY
```
SELECT * FROM テーブル名 ORDER BY ソートしたいカラム[,ソートしたいカラム] 並び順の指定
```

|指定|説明|
|--|--|
|ASC|昇順|
|DESC|降順|

並び順の指定を省略した場合はASCがデフォルトです。  
複数のソートキーも対応しています。はじめに書くほど優先でカラムが実行されます。

# SELECT COUNT　データの件数を数える
データの件数を数えます。
```
select count(*) from テーブル名;
```
実際に実行してみましょう
```
select count(*) from users;
```

# LIMIT 取得する件数を表示する
```
select * from テーブル名 LIMIT 取得件数;
```
実際にやってみましょう。
```
select * from users LIMIT 10;
```
画像を見て頂くとわかりますが、ageの列をみると、並びはバラバラですね。

# ORDER BY 並び順を省略してみる
```
select * from users ORDER BY age DESC LIMIT 10;
```

# DESCRIBE
テーブルの定義情報を確認することが出来るのがDESCRIBE文です。
```
DESCRIBE テーブル名;
```

# EXPLAIN
ここからは少しコストの話しも含めて理解するために「EXPLAIN」というSQLをご紹介します。  
RMDBSではオプティマイザという機能があり、データの分布情報を示す、統計情報に合わせてRMDBSの内部で処理の最適化を行ってくれます。  
EXPLAINを使う事で内部の実行コストがある程度分かります。

# EXPLAIN 出力フォーマット
|カラム|意味|
|--|--|
|id|SELECT 識別子|
|select_type|SELECT 型|
|table|出力行のテーブル|
|partitions|一致するパーティション|
|type|結合型|
|possible_keys|選択可能なインデックス|
|key|実際に選択されたインデックス|
|key_len|選択されたキーの長さ|
|ref|インデックスと比較されるカラム|
|rows|調査される行の見積もり|
|filtered|テーブル条件によってフィルタ処理される行の割合|
|Extra|追加情報|

詳細のところはまたどこかで説明するとして今回紹介しておきたいのは

「type」です。

|種類|説明|
|--|--|
|const|PRIMARY KEYまたはUNIQUEインデックスのルックアップによるアクセス。最速。|
|eq_ref|JOINにおいてPRIARY KEYまたはUNIQUE KEYが利用される時のアクセスタイプ。constと似ているがJOINで用いられるところが違う。|
|ref|ユニーク（PRIMARY or UNIQUE）でないインデックスを使って等価検索（WHERE key = value）を行った時に使われるアクセスタイプ。|
|range|インデックスを用いた範囲検索。|
|index|フルインデックススキャン。インデックス全体をスキャンする必要があるのでとても遅い。|
|ALL|フルテーブルスキャン。インデックスがまったく利用されていないことを示す。OLTP系の処理では改善必須。|

ルックアップ？  
→ITの分野では、表やデータ列などの中から条件に合う項目を探し出す処理などを指すことが多い。「サーチ」（search）とほぼ同義だが、サーチは未知の不特定の対象を条件などを手掛かりに探し求める場合に使われることが多い一方、ルックアップは既知の特定の対象を限られた範囲から見つけ出すことを指すことが多い。

# 主キーをソートキーに指定してみる
```
EXPLAIN SELECT * FROM users ORDER BY id DESC  LIMIT 10 ;
```
「type」が「index」になっていますね。  
「rows」が「10」になっていますね。

これは索引となるINDEXだけをみたので、検索時に触った件数が「10」件だった事が読み取れます。  

+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+---------------------+
| id | select_type | table | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra               |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+---------------------+
|  1 | SIMPLE      | users | NULL       | index | NULL          | PRIMARY | 4       | NULL |   10 |   100.00 | Backward index scan |
+----+-------------+-------+------------+-------+---------------+---------+---------+------+------+----------+---------------------+

# 主キー以外をソートキーに指定してみる
では主キー以外をソートキーに指定してみるとどうでしょうか？
```
EXPLAIN SELECT * FROM users ORDER BY name DESC  LIMIT 10 ;
```

「type」が「all」になっていますね。  
「rows」が「100」になっていますね。  
「Extra」が「Using filesort」になっていますね。

これは索引となるINDEXだけが存在しなかったため、テーブルの情報を全件検索した後に、ソート(並び替え)を行ってから、結果を表示していることが読み取れます。  
名前のカラムに対して降順で10件取得したいだけなのに、わざわざテーブルの全件を検索してから、並び替えた後に検索結果を10件と絞り込んでいます。

このテーブルの全件を検索してからという箇所が大変やっかいな話しなのです。

RMDBSはパフォーマンスを最大化するためにハードウェアのリソース(CPU,メモリ,HDD)を頑張って利用する設計に大抵はなっていますが、このテーブル上のデータを律儀に全件を検索してからというのは、モノを取り出すのに遅い、冷蔵庫から毎回データを取り出していることになります。

しかも10件だけ表示したいのに、テーブルの全件を検索するなんて、とてもナンセンスですよね。  
100件だけだったら、何も差を感じないと思いますが、これがテーブルに保持されているレコード件数が1000万件だったらどうでしょうか？想像してみてください。

# 演習
データ量の多いareasテーブルで色々ソートしてみましょう。  
【新人教育 資料】第5章 SQLへの道 〜絞込編〜で紹介しているSQLをEXPLAINで実行してみましょう。